# P13-001: スケルトン取得ロジック設計メモ

**作成日**: 2026-01-27
**対応要件**: FR-081, FR-082, FR-083
**依存**: P12-010（Phase 12完了）

---

## 1. 概要

本設計メモでは、FBXエクスポート機能においてAnimatorコンポーネントからボーン階層（スケルトン）を取得するロジックを設計する。取得したスケルトン情報は`SkeletonData`クラスに格納され、FBXエクスポート時に使用される。

---

## 2. 要件分析

### 2.1 対象要件

| 要件ID | 要件内容 | 本設計での対応 |
|--------|----------|----------------|
| FR-081 | FBX出力にスケルトン（ボーン階層）を含める | SkeletonExtractorクラスでボーン階層を取得 |
| FR-082 | スケルトン以外のGameObjectのTransformアニメーションも含める | 非スケルトンTransform検出機能（P13-005で実装） |
| FR-083 | FBX出力にマージされたアニメーションカーブを含める | 既存のMergedClipを活用 |

### 2.2 スケルトン取得の条件

Animatorからスケルトンを取得する際、以下のケースを考慮する：

1. **Humanoidリグの場合**
   - `Animator.avatar`がHumanoid型
   - `HumanBodyBones`を使用してボーンを取得
   - `Animator.GetBoneTransform()`でTransformを取得

2. **Genericリグの場合**
   - `Animator.avatar`がGeneric型またはnull
   - Animator配下のTransform階層を探索
   - SkinnedMeshRendererのボーン参照から取得

3. **Legacyアニメーションの場合**
   - Animatorがない、またはAnimator.avatarがない
   - Animationコンポーネントを参照
   - SkinnedMeshRendererのボーン配列から取得

---

## 3. クラス設計

### 3.1 SkeletonExtractor クラス

スケルトン取得の責務を持つ新規クラス。

```csharp
namespace AnimationMergeTool.Editor.Infrastructure
{
    /// <summary>
    /// Animatorからスケルトン（ボーン階層）を抽出するクラス
    /// </summary>
    public class SkeletonExtractor
    {
        /// <summary>
        /// Animatorからスケルトン情報を取得する
        /// </summary>
        /// <param name="animator">対象のAnimator</param>
        /// <returns>スケルトン情報（取得できない場合は空のSkeletonData）</returns>
        public SkeletonData Extract(Animator animator);

        /// <summary>
        /// Humanoidリグからスケルトンを取得する
        /// </summary>
        private SkeletonData ExtractFromHumanoid(Animator animator);

        /// <summary>
        /// Generic/Legacyリグからスケルトンを取得する
        /// </summary>
        private SkeletonData ExtractFromGeneric(Animator animator);

        /// <summary>
        /// SkinnedMeshRendererからボーン配列を取得する
        /// </summary>
        private List<Transform> GetBonesFromSkinnedMeshRenderers(GameObject root);

        /// <summary>
        /// Transform階層を深さ優先で探索してボーンリストを構築する
        /// </summary>
        private void CollectBonesRecursive(Transform parent, List<Transform> bones);

        /// <summary>
        /// ルートボーンを特定する
        /// </summary>
        private Transform FindRootBone(Animator animator, List<Transform> bones);
    }
}
```

### 3.2 ファイル配置

```
Scripts/Editor/Infrastructure/
├── FbxAnimationExporter.cs     (既存)
├── FbxPackageChecker.cs        (既存)
└── SkeletonExtractor.cs        (新規 - P13-003で実装)
```

---

## 4. スケルトン取得アルゴリズム

### 4.1 メイン処理フロー

```
Extract(animator)
    │
    ├─ animator == null ?
    │       → 空のSkeletonDataを返す
    │
    ├─ IsHumanoid(animator) ?
    │       → ExtractFromHumanoid(animator)
    │
    └─ else
            → ExtractFromGeneric(animator)
```

### 4.2 Humanoidリグからの取得

```csharp
private SkeletonData ExtractFromHumanoid(Animator animator)
{
    var bones = new List<Transform>();

    // 全HumanBodyBonesを列挙してTransformを取得
    foreach (HumanBodyBones bone in Enum.GetValues(typeof(HumanBodyBones)))
    {
        if (bone == HumanBodyBones.LastBone) continue;

        Transform boneTransform = animator.GetBoneTransform(bone);
        if (boneTransform != null && !bones.Contains(boneTransform))
        {
            bones.Add(boneTransform);
        }
    }

    // ルートボーンを特定（Hipsが一般的）
    Transform rootBone = animator.GetBoneTransform(HumanBodyBones.Hips);
    if (rootBone == null && bones.Count > 0)
    {
        // Hipsがない場合は最も浅い階層のボーンをルートとする
        rootBone = FindShallowestBone(bones, animator.transform);
    }

    // ボーンを階層順にソート
    SortBonesByHierarchy(bones, rootBone);

    return new SkeletonData(rootBone, bones);
}
```

### 4.3 Generic/Legacyリグからの取得

```csharp
private SkeletonData ExtractFromGeneric(Animator animator)
{
    var bones = new List<Transform>();

    // 方法1: SkinnedMeshRendererのボーン配列から取得
    var skinnedMeshRenderers = animator.GetComponentsInChildren<SkinnedMeshRenderer>();
    foreach (var smr in skinnedMeshRenderers)
    {
        if (smr.bones != null)
        {
            foreach (var bone in smr.bones)
            {
                if (bone != null && !bones.Contains(bone))
                {
                    bones.Add(bone);
                }
            }
        }

        // ルートボーンも追加
        if (smr.rootBone != null && !bones.Contains(smr.rootBone))
        {
            bones.Add(smr.rootBone);
        }
    }

    // 方法2: ボーンが取得できない場合はTransform階層を探索
    if (bones.Count == 0)
    {
        CollectBonesRecursive(animator.transform, bones);
    }

    // ルートボーンを特定
    Transform rootBone = FindRootBone(animator, bones);

    // ボーンを階層順にソート
    SortBonesByHierarchy(bones, rootBone);

    return new SkeletonData(rootBone, bones);
}
```

### 4.4 ルートボーン特定ロジック

```csharp
private Transform FindRootBone(Animator animator, List<Transform> bones)
{
    // 優先順位:
    // 1. SkinnedMeshRendererのrootBone
    // 2. Animatorの子で最も浅い階層のボーン
    // 3. bones配列の最初の要素

    var skinnedMeshRenderers = animator.GetComponentsInChildren<SkinnedMeshRenderer>();
    foreach (var smr in skinnedMeshRenderers)
    {
        if (smr.rootBone != null && bones.Contains(smr.rootBone))
        {
            return smr.rootBone;
        }
    }

    return FindShallowestBone(bones, animator.transform);
}

private Transform FindShallowestBone(List<Transform> bones, Transform root)
{
    Transform shallowest = null;
    int minDepth = int.MaxValue;

    foreach (var bone in bones)
    {
        int depth = GetDepth(bone, root);
        if (depth < minDepth)
        {
            minDepth = depth;
            shallowest = bone;
        }
    }

    return shallowest;
}

private int GetDepth(Transform transform, Transform root)
{
    int depth = 0;
    Transform current = transform;
    while (current != null && current != root)
    {
        depth++;
        current = current.parent;
    }
    return depth;
}
```

### 4.5 階層順ソートロジック

```csharp
private void SortBonesByHierarchy(List<Transform> bones, Transform rootBone)
{
    if (rootBone == null || bones.Count == 0) return;

    var sorted = new List<Transform>();
    var queue = new Queue<Transform>();
    queue.Enqueue(rootBone);

    // 幅優先探索で階層順に追加
    while (queue.Count > 0)
    {
        var current = queue.Dequeue();
        if (bones.Contains(current) && !sorted.Contains(current))
        {
            sorted.Add(current);
        }

        // 子を追加
        for (int i = 0; i < current.childCount; i++)
        {
            var child = current.GetChild(i);
            if (bones.Contains(child))
            {
                queue.Enqueue(child);
            }
        }
    }

    // 元のリストを更新
    bones.Clear();
    bones.AddRange(sorted);
}
```

---

## 5. エッジケース対応

### 5.1 考慮すべきケース

| ケース | 対応 |
|--------|------|
| Animatorがnull | 空のSkeletonDataを返す |
| Animator.avatarがnull | Generic扱いでTransform階層から取得 |
| SkinnedMeshRendererがない | Transform階層を探索 |
| ボーンが0件 | 空のSkeletonDataを返す |
| 循環参照（不正なTransform階層） | 探索済みTransformをHashSetで管理 |
| 同じTransformが複数のSMRで参照されている | 重複チェックで1つだけ追加 |

### 5.2 ボーン判定基準

Transform階層を探索する際、以下の基準でボーンかどうかを判定する：

1. **ボーンとみなす条件**
   - SkinnedMeshRendererのbones配列に含まれている
   - HumanBodyBonesでマッピングされている
   - 子にMeshRenderer/SkinnedMeshRendererを持たない

2. **ボーンから除外する条件**
   - MeshFilterコンポーネントを持つ
   - コライダーのみを持つ
   - 名前が明らかにボーンでない（Camera, Light等）

---

## 6. FbxAnimationExporterとの統合

### 6.1 呼び出し箇所

`FbxAnimationExporter`クラスでスケルトン取得を行う：

```csharp
public class FbxAnimationExporter
{
    private readonly SkeletonExtractor _skeletonExtractor = new SkeletonExtractor();

    /// <summary>
    /// FbxExportDataを生成する
    /// </summary>
    public FbxExportData CreateExportData(Animator animator, AnimationClip mergedClip)
    {
        // スケルトン取得
        SkeletonData skeleton = _skeletonExtractor.Extract(animator);

        // TransformカーブとBlendShapeカーブの抽出（P13-005以降で実装）
        var transformCurves = ExtractTransformCurves(mergedClip);
        var blendShapeCurves = ExtractBlendShapeCurves(mergedClip);

        // Humanoidリグかどうかを判定
        bool isHumanoid = animator != null &&
                          animator.avatar != null &&
                          animator.avatar.isHuman;

        return new FbxExportData(
            animator,
            mergedClip,
            skeleton,
            transformCurves,
            blendShapeCurves,
            isHumanoid
        );
    }
}
```

---

## 7. テスト方針（P13-002で作成）

### 7.1 テストケース

1. **Humanoidリグからのスケルトン取得**
   - 全HumanBodyBonesが取得できること
   - Hipsがルートボーンとして設定されること

2. **Genericリグからのスケルトン取得**
   - SkinnedMeshRendererのボーンが全て取得できること
   - rootBoneが正しく設定されること

3. **ボーンの階層順ソート**
   - 親から子の順に並んでいること
   - 同一階層のボーンが連続していること

4. **エッジケース**
   - Animatorがnullの場合
   - SkinnedMeshRendererがない場合
   - ボーンが0件の場合

---

## 8. 次のステップ

1. **P13-002**: 本設計に基づきスケルトン取得のテストを作成
2. **P13-003**: SkeletonExtractorクラスを実装
3. **P13-004**: 非スケルトンTransform取得のテストを作成
4. **P13-005**: 非スケルトンTransform取得機能を実装

---

## 更新履歴

| バージョン | 日付 | 変更内容 |
|------------|------|----------|
| 1.0 | 2026-01-27 | 初版作成 |
